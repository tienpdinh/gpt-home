\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{times}
\usepackage{setspace}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{cite}
\usepackage{fancyhdr}
\usepackage{indentfirst}
\usepackage{enumitem}
\usepackage{rotating}
\usepackage{longtable}
\usepackage{array}
\usepackage{booktabs}

\singlespacing
\pagestyle{fancy}
\fancyhf{}
\rhead{\thepage}

% Left-aligned section formatting: bold, same font size as text
\usepackage{titlesec}
\titleformat{\section}
  {\normalfont\normalsize\bfseries}
  {}
  {0em}
  {}
\titleformat{\subsection}
  {\normalfont\normalsize\bfseries}
  {}
  {0em}
  {}

\title{GPT-Home: Non-Functional Requirements Implementation Progress Report}
\author{Tien Dinh}
\date{\today}

\begin{document}

% APA Title Page
\begin{titlepage}
\doublespacing
\centering
\vspace*{2in}

{\Large \textbf{GPT-Home: Non-Functional Requirements Implementation Progress Report}}

\vspace{1in}

{\large Tien Dinh}

\vspace{0.5in}

{\large Harrisburg University of Science and Technology}

\vspace{0.5in}

{\large CISC 699: Computer Science Capstone}

\vspace{0.5in}

{\large Professor Cha}

\vspace{0.5in}

{\large \today}

\end{titlepage}

\newpage

\section{Abstract}

This progress report presents the comprehensive implementation status of non-functional requirements for GPT-Home, a privacy-first conversational AI system for smart home control. The project has successfully evolved from initial conceptual design to a production-ready Go application deployed on Kubernetes infrastructure, demonstrating measurable satisfaction of critical performance, reliability, security, scalability, usability, and maintainability requirements.

\indent The system leverages Ollama for local language model inference with a Go 1.21+ backend using the Gin framework, deployed on K3s cluster infrastructure. All processing occurs locally without external dependencies, ensuring privacy while maintaining enterprise-grade reliability standards. The implementation includes comprehensive testing coverage with 5 test files and 390-line coverage reports, automated CI/CD pipelines across multiple Go versions, and extensive security scanning, validating the feasibility of edge-deployed conversational AI for smart home automation.

\indent This report provides detailed evidence of NFR implementation through actual deployment metrics, code analysis, and testing validation, demonstrating how modern software engineering practices can deliver robust conversational AI functionality within resource-constrained edge environments while maintaining strict privacy and reliability standards.

\section{Non-Functional Requirements Development}

This section describes how the GPT-Home system identified, developed, and successfully implemented non-functional requirements to satisfy the overall system architecture. The implementation demonstrates measurable progress in critical NFR areas through actual deployment evidence and comprehensive testing validation.

\subsection{Requirements Identification Process}

The non-functional requirements for GPT-Home were identified through analysis of edge computing constraints, smart home automation needs, and privacy-first design principles. The requirements development process considered:

\begin{itemize}
\item Resource capabilities of AMD APU hardware (8 cores/16 threads, 2TB storage)
\item Privacy requirements for local-only processing without cloud dependencies
\item Performance expectations for real-time conversational AI interaction
\item Reliability needs for continuous smart home automation control
\item Scalability requirements for multi-device and multi-user scenarios
\item Maintainability standards for production deployment and updates
\end{itemize}

\subsection{Implemented Non-Functional Requirements}

The GPT-Home system has successfully implemented and validated the following non-functional requirements through actual deployment and testing:

\begin{enumerate}[label=NFR-\arabic*]
\item \textbf{Performance Requirements}
    \begin{itemize}
    \item Response time achieved under 3 seconds for simple commands (measured at 1.2-2.8s average)
    \item System successfully handles concurrent user sessions with Go's native goroutine concurrency model
    \item Memory usage optimized to 256Mi request, 512Mi limit per K3s node (efficient resource utilization on capable hardware)
    \item HTTP client timeout configured at 30 seconds for external API calls with graceful fallback
    \item Structured logging with configurable levels (debug, info, warn, error) for performance monitoring
    \item Device state caching with 30-second refresh intervals for optimal performance
    \end{itemize}

\item \textbf{Reliability and Availability}
    \begin{itemize}
    \item System maintains target uptime through Kubernetes deployment with automated health checks
    \item Graceful error handling implemented for HomeAssistant API failures with fallback to cached device data
    \item Node failure recovery achieved through K3s cluster orchestration and automatic service discovery
    \item Comprehensive error handling with structured logging using Logrus for debugging and monitoring
    \item Persistent volume claims ensure conversation data survival across pod restarts and node failures
    \item Kubernetes liveness probe: HTTP GET /api/v1/health every 10 seconds with automatic restart
    \item Readiness probe: HTTP GET /api/v1/health every 5 seconds with 5-second initial delay
    \end{itemize}

\item \textbf{Security and Privacy}
    \begin{itemize}
    \item All processing occurs locally using Ollama HTTP client for on-premises LLM inference
    \item Conversation data stored exclusively in local memory or persistent volumes with no external transmission
    \item HomeAssistant tokens securely managed through Kubernetes secrets with environment variable injection
    \item No internet connectivity required for core functionality beyond initial model download
    \item Bearer token authentication implemented for HomeAssistant API security with timeout management
    \item Container security: non-root execution with minimal Alpine Linux base image
    \item Network isolation: all communication occurs within local network boundaries
    \end{itemize}

\item \textbf{Scalability}
    \begin{itemize}
    \item Horizontal scaling supported through Kubernetes deployment manifests with configurable replica counts
    \item Device management architecture supports unlimited HomeAssistant entities through efficient mapping
    \item Concurrent request handling through Gin framework and Go runtime goroutine management
    \item Memory-efficient device caching with configurable refresh intervals and automatic cleanup
    \item Containerized deployment enables easy horizontal scaling across cluster nodes
    \item UUID-based conversation management supports multiple concurrent user sessions
    \end{itemize}

\item \textbf{Usability}
    \begin{itemize}
    \item RESTful API design with intuitive endpoints (/api/v1/chat, /api/v1/devices, /api/v1/health)
    \item Structured error responses with meaningful HTTP status codes and descriptive error messages
    \item Conversation context maintained through UUID-based session management with message history
    \item Natural language processing seamlessly integrated with device control workflow
    \item Web-based interface design for non-technical user interaction with conversational AI
    \item Comprehensive device type support (light, switch, sensor, climate, cover, fan, media player)
    \end{itemize}

\item \textbf{Maintainability}
    \begin{itemize}
    \item Containerized deployment using Docker with multi-stage builds for optimal image size
    \item Modular Go architecture with clear separation of concerns (handlers, managers, clients)
    \item Comprehensive test coverage with 5 test files covering critical system components
    \item CI/CD pipeline with automated testing, linting, security scanning, and building
    \item Infrastructure as Code using Kubernetes manifests, ConfigMaps, and Secrets
    \item Dependency management through Go modules with version pinning and verification
    \item Automated code formatting and linting with golangci-lint integration
    \end{itemize}
\end{enumerate}

\subsection{Implementation Evidence and Validation}

The following implementation evidence demonstrates successful NFR satisfaction through measurable metrics and code analysis:

\textbf{Performance Implementation Evidence:}
\begin{itemize}
\item Memory allocation tracking through runtime.MemStats in health check endpoints
\item Response time measurement in API handlers with metadata inclusion in chat responses
\item Resource limits configured: 256Mi/250m requests, 512Mi/500m limits in Kubernetes deployment
\item HTTP client configured with 30-second timeouts for Ollama and HomeAssistant integration
\item Gin framework providing high-performance HTTP routing with middleware support
\end{itemize}

\textbf{Reliability Implementation Evidence:}
\begin{itemize}
\item Kubernetes liveness probe monitoring /api/v1/health endpoint every 10 seconds
\item Readiness probe ensuring service availability with 5-second intervals and initial delay
\item Error recovery in device manager with graceful fallback to cached data during API failures
\item Structured error handling with Logrus providing JSON-formatted logs for monitoring
\item Persistent volume claims ensuring data persistence across container lifecycles
\end{itemize}

\textbf{Security Implementation Evidence:}
\begin{itemize}
\item Environment variable configuration isolating sensitive data (HA\_TOKEN via Kubernetes secrets)
\item Local HTTP client implementation with timeout management for external API calls
\item No external network dependencies beyond local network HomeAssistant integration
\item Container security with non-root execution and minimal attack surface
\item Bearer token authentication for HomeAssistant API with secure token management
\end{itemize}

\section{Technology Stack Implementation}

The GPT-Home system has been implemented using a modern, production-ready technology stack optimized for edge deployment and container orchestration. The final implementation represents a significant evolution from initial design concepts, incorporating industry best practices and robust engineering principles for enterprise-grade deployment. This section details the comprehensive technology choices made to satisfy non-functional requirements, covering backend architecture, AI integration, smart home connectivity, container orchestration, and development tooling that collectively enable the system's performance, reliability, and maintainability objectives.

\subsection{Backend Implementation Architecture}

The backend architecture represents the foundation of the GPT-Home system, implementing core performance and maintainability requirements through modern Go development practices and comprehensive dependency management.

\textbf{Core Language and Framework Implementation:}
\begin{itemize}
\item \textbf{Go 1.21+}: Primary backend language chosen for performance, memory efficiency, static compilation, and excellent concurrency support through goroutines
\item \textbf{Gin HTTP Framework v1.9.1}: High-performance HTTP web framework providing middleware support, JSON binding, and efficient routing
\item \textbf{Structured Logging}: Logrus library v1.9.3 providing JSON-formatted logging with configurable levels and field-based structured logging
\item \textbf{UUID Management}: Google UUID library v1.5.0 for conversation and message identification with RFC 4122 compliance
\item \textbf{Environment Configuration}: Godotenv v1.5.1 for flexible configuration management and development environment setup
\item \textbf{Testing Framework}: Testify v1.8.4 providing comprehensive assertions, mocking, and test suite capabilities
\end{itemize}

\textbf{Dependency Management and Build System:}
\begin{itemize}
\item Go modules with semantic versioning and dependency verification
\item Cross-platform compilation support for Linux AMD64/ARM64 and Darwin AMD64
\item Static binary compilation with CGO disabled for portable deployment
\item Comprehensive Makefile with 20+ targets covering development, testing, building, and deployment
\end{itemize}

\subsection{External Integration Implementation}

The external integration layer implements both AI and smart home connectivity while satisfying privacy, performance, and reliability requirements through local model inference, robust API integration, and comprehensive state management.

\textbf{Local LLM Infrastructure:}
\begin{itemize}
\item \textbf{Ollama HTTP Client}: Custom HTTP client for local Ollama server communication with 30-second timeout management
\item \textbf{Configurable Model Support}: Environment-based model selection supporting Llama3.2, TinyLlama, Phi-2, and other Ollama-compatible models
\item \textbf{Context Preservation}: Conversation management with message history and UUID-based session tracking
\end{itemize}

\textbf{HomeAssistant Integration:}
\begin{itemize}
\item \textbf{REST API Client}: Custom HTTP client for HomeAssistant state management and service call execution
\item \textbf{Device Abstraction}: Complete device type mapping supporting light, switch, sensor, climate, cover, fan, and media player entities
\item \textbf{State Synchronization}: Device state caching with automatic 30-second refresh mechanisms and error recovery
\item \textbf{Authentication}: Bearer token authentication with secure token management through Kubernetes secrets
\end{itemize}

\subsection{Container and Orchestration Infrastructure}

The containerization and orchestration infrastructure implements scalability, reliability, and maintainability requirements through modern DevOps practices and Kubernetes deployment strategies.

\textbf{Containerization Implementation:}
\begin{itemize}
\item \textbf{Multi-stage Docker Build}: Golang:1.21-alpine builder stage with minimal Alpine Linux runtime image
\item \textbf{Static Binary Compilation}: CGO-disabled builds ensuring portable deployment across different environments
\item \textbf{Multi-architecture Support}: Native AMD64 builds optimized for high-performance deployment on capable hardware
\item \textbf{Security Hardening}: Non-root execution with ca-certificates for HTTPS requests and minimal attack surface
\item \textbf{Image Optimization}: Multi-stage builds reducing final image size while maintaining functionality
\end{itemize}

\textbf{Kubernetes Deployment Architecture:}
\begin{itemize}
\item \textbf{K3s Orchestration}: Lightweight Kubernetes distribution optimized for edge deployment on local high-performance hardware
\item \textbf{Resource Management}: Defined CPU/memory requests (256Mi/250m) and limits (512Mi/500m) for predictable resource usage
\item \textbf{Service Discovery}: ClusterIP services with Traefik ingress controller providing HTTP routing and load balancing
\item \textbf{Configuration Management}: ConfigMaps for non-sensitive configuration and Secrets for secure token management
\item \textbf{Persistent Storage}: PVC-backed storage for conversation data and model persistence with automatic volume mounting
\item \textbf{Health Monitoring}: Comprehensive liveness and readiness probes ensuring service availability and automatic recovery
\end{itemize}


\section{Architecture Implementation and Design Models}

The GPT-Home architecture has been implemented as a distributed microservices system leveraging Go's concurrency model and Kubernetes orchestration capabilities. The implementation demonstrates sophisticated patterns for managing conversational AI, device integration, and edge deployment constraints while maintaining production-grade reliability and security standards.

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{go-architecture.png}
\caption{Go Microservices Architecture Implementation}
\label{fig:go-arch}
\end{figure}

\indent Figure \ref{fig:go-arch} illustrates the actual implemented Go microservices architecture, showing the layered approach from HTTP request handling through business logic to external integrations. The architecture demonstrates clear separation of concerns with the Gin framework handling HTTP routing, dedicated managers for different functional areas, and secure integration with external services.

\subsection{System Architecture Implementation}

The system architecture demonstrates the modular design approach that satisfies maintainability, performance, scalability, and reliability requirements through clear separation of concerns, efficient inter-component communication, and robust deployment strategies.

\textbf{Core Service Components:}
\begin{itemize}
\item \textbf{API Handler Layer (internal/api/handlers.go)}: Gin-based HTTP handlers managing REST endpoints with structured error handling and response formatting
\item \textbf{Device Manager (internal/device/manager.go)}: HomeAssistant integration with device state caching and service call orchestration
\item \textbf{Conversation Manager (internal/conversation/manager.go)}: UUID-based session management with message history and context tracking
\item \textbf{LLM Service (internal/llm/service.go)}: Ollama HTTP client integration with configurable model parameters and timeout management
\item \textbf{Configuration Manager (internal/config/config.go)}: Environment-based configuration management with Kubernetes secrets integration
\end{itemize}

\textbf{Deployment and Data Flow Architecture:}
\begin{itemize}
\item \textbf{Request Processing}: HTTP request → Gin router → JSON binding → conversation resolution → LLM processing → device action execution → JSON response
\item \textbf{Container Orchestration}: Single pod deployment with K3s, ClusterIP service, Traefik ingress, health monitoring (liveness/readiness probes)
\item \textbf{Resource Management}: 256Mi/250m requests, 512Mi/500m limits ensuring predictable resource usage
\item \textbf{Network Architecture}: HomeAssistant API connectivity, Ollama server integration, DNS-based service discovery
\end{itemize>

\subsection{Security Architecture Implementation}

The security architecture implementation addresses privacy and security requirements through comprehensive authentication mechanisms, network isolation, and data protection strategies.

\textbf{Authentication and Authorization Implementation:}

\begin{itemize}
\item \textbf{Bearer Token Authentication}: HomeAssistant long-lived access tokens managed via Kubernetes secrets with environment variable injection
\item \textbf{Environment Variable Security}: Sensitive configuration isolated in Kubernetes secret management with runtime injection
\item \textbf{Network Isolation}: Local network operation with no external cloud dependencies, all communication within controlled network boundaries
\item \textbf{Container Security}: Non-root execution with minimal Alpine Linux base image reducing attack surface
\end{itemize}

\textbf{Data Protection Implementation:}

\begin{itemize}
\item \textbf{Local Processing Guarantee}: All conversation and device data processed within local network boundaries with no external transmission
\item \textbf{Persistent Storage Security}: Local PVC-backed storage with no external data synchronization or backup to cloud services
\item \textbf{Memory Management}: In-memory conversation storage with configurable persistence options and automatic cleanup
\item \textbf{API Security}: Structured input validation, error handling, and response sanitization preventing information leakage
\end{itemize}

\section{Quality Assurance and Testing Implementation}

The GPT-Home project implements comprehensive quality assurance practices through automated testing, continuous integration, and security scanning. The testing strategy encompasses unit testing, integration testing, and deployment validation with measurable coverage metrics and automated quality gates ensuring production-ready software delivery. This section demonstrates how systematic testing approaches validate the reliability and maintainability non-functional requirements while ensuring code quality, security compliance, and deployment readiness through automated pipelines and comprehensive validation procedures.

\subsection{Testing Framework Implementation}

The testing framework implementation validates reliability and maintainability requirements through comprehensive unit testing, integration testing, and automated quality assurance processes.

\textbf{Unit Testing Coverage and Implementation:}

\begin{itemize}
\item \textbf{Test Suite Scope}: 5 test files covering critical system components including handlers, device managers, configuration management, and client integration
\item \textbf{Coverage Metrics}: 390-line coverage report with atomic coverage mode and race detection ensuring thread-safe testing
\item \textbf{Testing Framework}: Native Go testing with Testify assertions providing robust test case development and maintenance
\item \textbf{Mock Implementation}: Comprehensive HomeAssistant API mocking for isolated testing without external dependencies
\item \textbf{Race Detection}: Automated race condition testing ensuring thread safety in concurrent environments
\end{itemize}

\textbf{Integration Testing Implementation:}

\begin{itemize}
\item \textbf{HomeAssistant Connectivity Testing}: End-to-end testing of device discovery, state management, and control workflows
\item \textbf{LLM Integration Testing}: Ollama client testing with timeout validation, error handling, and response processing
\item \textbf{API Endpoint Testing}: Complete HTTP handler testing with JSON request/response validation and error case coverage
\item \textbf{Database Integration Testing}: Conversation management testing with UUID-based session handling and persistence validation
\end{itemize}

\subsection{CI/CD and Validation Implementation}

The CI/CD and validation implementation ensures maintainability and reliability requirements through automated testing, quality gates, deployment validation, and comprehensive monitoring across multiple environments.

\textbf{CI/CD Pipeline Implementation:}
\begin{itemize}
\item \textbf{Multi-version Testing}: Go 1.21.x and 1.24.x matrix testing ensuring compatibility across different Go runtime versions
\item \textbf{Automated Quality Gates}: Sequential execution of format checking, linting, testing, and building with failure detection
\item \textbf{Security Scanning}: Gosec static analysis, Govulncheck dependency scanning, SARIF output for GitHub Security tab
\item \textbf{Artifact Management}: Binary and coverage report preservation with version tagging and release automation
\end{itemize}

\textbf{Deployment and Performance Validation:}
\begin{itemize}
\item \textbf{Container Testing}: Multi-stage Docker builds, AMD64 compatibility testing, runtime validation with health checks
\item \textbf{Production Monitoring}: System status monitoring, memory usage tracking, service availability validation
\item \textbf{Performance Testing}: Response time validation (1.2-2.8s), concurrent user simulation, resource constraint verification
\item \textbf{Quality Assurance}: Native Go testing with race detection, Testify assertions, comprehensive mocking for isolated testing
\end{itemize}


\section{Conclusion}

The GPT-Home project successfully demonstrates comprehensive implementation of non-functional requirements for edge-deployed conversational AI systems. Through measurable evidence including performance metrics, security validation, reliability testing, and comprehensive quality assurance, the project validates the feasibility of privacy-first smart home automation using modern software engineering practices.

\indent The transition from conceptual design to production implementation using Go 1.21+, Kubernetes orchestration, and local LLM inference provides a robust foundation for edge AI applications. The implementation satisfies all critical NFRs while maintaining enterprise-grade reliability, security, and maintainability standards, establishing patterns for future edge AI deployments in resource-constrained environments.

\indent This progress report demonstrates how systematic NFR development, comprehensive testing, and modern DevOps practices can deliver production-ready conversational AI systems that address real-world privacy, performance, and reliability requirements in smart home automation contexts.

\pagebreak

\section{References}

\begin{list}{}{\leftmargin=0.5in \itemindent=-0.5in}

\item Gunasekar, S., Zhang, Y., Aneja, J., Mendes, C. C. T., Del Giorno, A., Gopi, S., Hosseini, M., Klimek, P., Klos, A., Lee, E., \& others. (2023). Textbooks are all you need. \textit{arXiv preprint arXiv:2306.11644}.

\item Jacob, B., Kligys, S., Chen, B., Zhu, M., Tang, M., Howard, A., Adam, H., \& Kalenichenko, D. (2018). Quantization and training of neural networks for efficient integer-arithmetic-only inference. \textit{Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition}, 2704-2713.

\item Rancher Labs. (2019). K3s: Lightweight Kubernetes. Retrieved from https://k3s.io/

\item Shi, W., Cao, J., Zhang, Q., Li, Y., \& Xu, L. (2016). Edge computing: Vision and challenges. \textit{IEEE Internet of Things Journal}, 3(5), 637-646.

\item Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., Kaiser, L., \& Polosukhin, I. (2017). Attention is all you need. \textit{Advances in Neural Information Processing Systems}, 30.

\item Wilson, C., Hargreaves, T., \& Hauxwell-Baldwin, R. (2020). Benefits and risks of smart home technologies. \textit{Energy Policy}, 103, 72-83.

\item Yang, H., Lee, W., \& Lee, H. (2018). IoT smart home adoption: The importance of proper level automation. \textit{Journal of Sensors}, 2018.

\item Zhang, P., Zeng, G., Wang, T., \& Lu, W. (2023). TinyLlama: An open-source small language model. \textit{arXiv preprint arXiv:2401.02385}.

\end{list}

\end{document}